# -*- coding: utf-8 -*-
"""充電站路徑規劃專案＿final ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hmc57JNJzgaVeZq6DONV_By5CtFRkrA8
"""

import os
#!pip install -U googlemaps
import googlemaps
#!pip install --upgrade google-auth-oauthlib

gmaps = googlemaps.Client(key = "AIzaSyBf6nAgSmnUyTue-XM2RQh7EIgzUXM535s")

event = "成功大學"
loc = gmaps.geocode(event)[0]['geometry']['location']

loc

class map():
  def Latitude_longitude (self, origin, end):
    self.start = gmaps.geocode(origin)[0]["geometry"]["location"]
    self.final = gmaps.geocode(end)[0]["geometry"]["location"]
    return self.start, self.final

  def nearby(self, location_position,distance):
    self.distance = distance
    self.location = gmaps.places_nearby(location = (location_position), radius = 500000, keyword = "充電站")
    self.near = []
    for i in range(20):
      if self.location['results'][i]['geometry']['location']['lat']> location_position['lat']:
         self.near.append(self.location['results'][i]['geometry']['location'])
    return self.near,self.location
  
  def swap( a, b ):
    return b, a
  
    
  def dis_sta(self,near,start,final,fillpertimes,min_km):
    self.fillpertimes = fillpertimes
    self.min_km = min_km
    self.near = near
    self.start_dis= []
    self.start_dis_km = []
    for i in range(len(self.near)):
      self.start_result = ((gmaps.distance_matrix(self.start,self.near[i], mode='driving')["rows"][0]["elements"][0]["distance"]["value"])/1000)
      if self.start_result < self.fillpertimes and self.start_result > self.min_km:
        self.start_dis.append(self.near[i])      
        self.start_dis_km.append(self.start_result)
    
    
    return self.start_dis, self.start_dis_km
 
  def dis(self,x,y,start,final):
    self.x = x
    self.y = y
    self.start = start
    self.final = final
    self.start_result = gmaps.distance_matrix(self.start,self.x[0], mode='driving')["rows"][0]["elements"][0]["distance"]["value"]  
    self.end_result = gmaps.distance_matrix(self.x[0],self.final, mode='driving')["rows"][0]["elements"][0]["distance"]["value"] 
    self.min = self.start_result + self.end_result
    self.min_dis = self.y[0]
    self.geo = self.x[0]
    for j in range(1,len(self.x)):
      self.start_result1 = gmaps.distance_matrix(self.start,self.x[j], mode='driving')["rows"][0]["elements"][0]["distance"]["value"]  
      self.end_result1 = gmaps.distance_matrix(self.x[j],self.final, mode='driving')["rows"][0]["elements"][0]["distance"]["value"]  
      self.minn = self.start_result1 + self.end_result1
      if (self.minn < self.min): 
        self.min_dis = self.y[j]
        self.geo = self.x[j]
    return self.min_dis,  self.geo

  def isarrive(self, start,final,power):
    self.arrive = 0
    self.start = start
    self.final = final
    self.fillpertimes = fillpertimes
    self.distance = gmaps.distance_matrix(self.start,self.final, mode='driving')["rows"][0]["elements"][0]["distance"]["value"]  
    if self.distance < fillpertimes:
      self.arrive = 1
    else:
      self.arrive = 0
    return self.arrive


